/*
 * Copyright (c) 2019, Blair Butterworth
 *
 * This work is licensed under the MIT License. To view a copy of this
 * license, visit
 *
 *        https://opensource.org/licenses/MIT
 */

package com.evilbird.warcraft.action.construct;

import com.badlogic.gdx.math.Vector2;
import com.evilbird.engine.item.Item;
import com.evilbird.warcraft.action.common.scenario.ScenarioSetAction;
import com.evilbird.warcraft.item.unit.UnitType;
import com.evilbird.warcraft.item.unit.building.Building;

import javax.inject.Inject;
import java.util.function.Consumer;

import static com.evilbird.engine.action.common.ActionRecipient.Player;
import static com.evilbird.engine.action.common.ActionRecipient.Target;
import static com.evilbird.engine.action.common.AnimateAction.animate;
import static com.evilbird.engine.action.common.AudibleAction.play;
import static com.evilbird.engine.action.common.DisableAction.disable;
import static com.evilbird.engine.action.common.DisableAction.enable;
import static com.evilbird.engine.action.common.RepeatedAudibleAction.playRepeat;
import static com.evilbird.engine.action.common.VisibleAction.hide;
import static com.evilbird.engine.action.common.VisibleAction.show;
import static com.evilbird.engine.action.predicates.ActionPredicates.target;
import static com.evilbird.engine.item.utility.ItemPredicates.hasType;
import static com.evilbird.warcraft.action.common.create.CreateAction.create;
import static com.evilbird.warcraft.action.common.remove.RemoveAction.remove;
import static com.evilbird.warcraft.action.common.transfer.TransferAction.purchase;
import static com.evilbird.warcraft.action.common.transfer.TransferAction.transfer;
import static com.evilbird.warcraft.action.construct.ConstructAction.construct;
import static com.evilbird.warcraft.action.construct.ConstructEvents.constructCompleted;
import static com.evilbird.warcraft.action.construct.ConstructEvents.constructStarted;
import static com.evilbird.warcraft.action.construct.ConstructTimes.buildTime;
import static com.evilbird.warcraft.action.move.MoveAdjacent.moveAdjacentTarget;
import static com.evilbird.warcraft.action.move.MoveToItemAction.move;
import static com.evilbird.warcraft.action.select.SelectAction.deselect;
import static com.evilbird.warcraft.item.common.query.UnitPredicates.isAlive;
import static com.evilbird.warcraft.item.common.query.UnitPredicates.isConstructing;
import static com.evilbird.warcraft.item.common.query.UnitPredicates.isPlaceholder;
import static com.evilbird.warcraft.item.common.query.UnitPredicates.unassignConstruction;
import static com.evilbird.warcraft.item.unit.UnitAnimation.BuildingSite;
import static com.evilbird.warcraft.item.unit.UnitAnimation.Construct;
import static com.evilbird.warcraft.item.unit.UnitAnimation.Idle;
import static com.evilbird.warcraft.item.unit.UnitAnimation.Move;
import static com.evilbird.warcraft.item.unit.UnitCosts.costOf;
import static com.evilbird.warcraft.item.unit.UnitSound.Build;
import static com.evilbird.warcraft.item.unit.UnitSound.Complete;

/**
 * Instances of this class construct a building.
 *
 * @author Blair Butterworth
 */
public class ConstructSequence extends ScenarioSetAction
{
    private transient ConstructReporter reporter;

    /**
     * Constructs a new instance of this class given a {@link ConstructReporter}
     * used to report events generated by the construction action. Notably item
     * creation, resource transfer and construction events.
     *
     * @param reporter  a {@code ConstructReporter} instance. This parameter
     *                  cannot be {@code null}.
     */
    @Inject
    public ConstructSequence(ConstructReporter reporter) {
        this.reporter = reporter;
    }

    @Override
    protected void features() {
        ConstructActions action = (ConstructActions)getIdentifier();
        features(action.getUnitType());
    }

    private void features(UnitType building) {
        build(building);
        resume(building);
    }

    private void build(UnitType building) {
        scenario("Construct Building")
            .givenItem(isAlive())
            .whenTarget(isPlaceholder())
            .then(animate(Move))
            .then(move(reporter))
            .then(animate(Idle))
            .then(purchase(costOf(building), reporter))
            .then(remove(Target, reporter))
            .thenUpdate(create(building, properties(), reporter), this)
            .then(constructStarted(reporter))
            .then(hide(), disable(), deselect(reporter), animate(Target, Construct), unassignConstruction())
            .then(construct(buildProgress(building), buildTime(building)), playRepeat(Build, 3, 5))
            .then(show(), enable(), animate(Idle), animate(Target, Idle), play(Complete), moveAdjacentTarget())
            .then(transfer(Target, Player, reporter))
            .then(constructCompleted(reporter));
    }


    private void resume(UnitType building) {
        scenario("Resume Construction")
            .givenItem(isAlive())
            .whenTarget(hasType(building))
            .whenTarget(isConstructing())
            .then(construct(buildProgress(building), buildTime(building)), playRepeat(Build, target(isConstructing())))
            .then(show(), enable(), animate(Idle), animate(Target, Idle), play(Complete), moveAdjacentTarget())
            .then(transfer(Target, Player, reporter))
            .then(constructCompleted(reporter));
    }

    private Consumer<Item> properties() {
        Vector2 position = getTarget().getPosition();
        return (item) -> {
            Building building = (Building)item;
            building.setConstructionProgress(0);
            building.setAnimation(BuildingSite);
            building.setPosition(position);
            building.setVisible(true);
        };
    }

    private float buildProgress(UnitType unit) {
        Item target = getTarget();
        if (target instanceof Building) {
            Building building = (Building)target;
            return building.getConstructionProgress() * buildTime(unit);
        }
        return 0;
    }
}
